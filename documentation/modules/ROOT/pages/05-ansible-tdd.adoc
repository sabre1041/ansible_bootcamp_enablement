= Lab: Advanced Collection Testing

'''

== Objective

You will add a `db_server` role to an Ansible collection and configure an advanced, collection-level Molecule testing strategy. This involves creating a dedicated scenario for resource management and a separate scenario for functionally testing the role. This powerful pattern, ideal for collections with multiple components, uses `shared_state` to ensure test infrastructure is created only once, making the test suite faster and more efficient. ðŸ§ª

'''

== Prerequisites

* Ansible, Molecule, and Docker are installed.
* You are in a development directory where you can create a new collection.

'''

== Step 1: Create and Prepare the Collection

First, generate the collection and add the `db_server` role resource.

. Generate the collection skeleton:
+
[source,bash]
----
ansible-creator collection init ansible_bootcamp.my_collection
----

. Change into the collection directory. All subsequent actions are relative to this path.
+
[source,bash]
----
cd ansible_bootcamp.my_collection
----

. Add the `db_server` role:
+
[source,bash]
----
ansible-creator add resource role db_server
----

'''

== Step 2: Develop the `db_server` Role

Modify the files inside `roles/db_server/` to install and configure PostgreSQL.

=== Define Default Variables (`roles/db_server/defaults/main.yml`)
[source,yaml,role=execute]
----
---
# defaults file for db_server
db_name: "webapp_prod"
db_user: "webapp_user"
db_password: "SecurePassword123"
----

=== Write the Main Tasks (`roles/db_server/tasks/main.yml`)
[source,yaml,role=execute]
----
---
# tasks file for db_server
- name: Install PostgreSQL and dependencies
  ansible.builtin.package:
    name:
      - postgresql-server
      - python3-psycopg2
    state: present
  become: true

- name: Initialize the PostgreSQL database
  ansible.builtin.command: postgresql-setup --initdb
  args:
    creates: /var/lib/pgsql/data/postgresql.conf
  become: true

- name: Ensure the PostgreSQL service is started and enabled
  ansible.builtin.service:
    name: postgresql
    state: started
    enabled: true
  become: true

- name: Create the application database
  community.postgresql.postgresql_db:
    name: "{{ db_name }}"
    state: present
  become: true
  become_user: postgres

- name: Create the application database user
  community.postgresql.postgresql_user:
    name: "{{ db_user }}"
    password: "{{ db_password }}"
    state: present
  become: true
  become_user: postgres

- name: Grant the user full privileges on the new database
  community.postgresql.postgresql_privs:
    db: "{{ db_name }}"
    privs: ALL
    type: database
    roles: "{{ db_user }}"
    grant_option: false
  become: true
  become_user: postgres
----

'''

== Step 3: Configure the Advanced Molecule Scenarios

Now, you will configure two separate scenarios in `extensions/molecule/`: one (`default`) to manage the Docker container lifecycle and another (`db_server`) to test the role.

=== Create a Base Configuration (`extensions/molecule/config.yml`)
This is a new, shared configuration file that other scenarios will inherit from. Create the file `extensions/molecule/config.yml` and add the following content.

[source,yaml,role=execute]
----
---
scenario:
  test_sequence:
    - converge
    - idempotence
    - verify
  shared_state: true

provisioner:
  name: ansible

verifier:
  name: ansible
----

=== Configure the `default` (Resource Management) Scenario
The `default` scenario will only create and destroy the test container.

.  **Modify `extensions/molecule/default/molecule.yml`:**
    Replace its contents to define the platform and override the test sequence.
[source,yaml,role=execute]
----
---
driver:
    name: docker
platforms:
    - name: instance
    image: "redhat/ubi9-init"
    pre_build_image: true
    privileged: true
scenario:
    test_sequence:
    - create
    - destroy
----

. **Clear out the default `converge.yml`:**
   The `default` scenario does not converge anything. Open `extensions/molecule/default/converge.yml` and delete its contents, leaving an empty file.

=== Create and Configure the `db_server` (Component Testing) Scenario
This new scenario will perform the actual test of the role.

. **Initialize the new scenario:**
   From the root of your collection, run:
   [source,bash]
   ----
   molecule init scenario db_server -d extensions/molecule
   ----

. **Create `extensions/molecule/db_server/molecule.yml`:**
   This file just needs to point to the base config.
[source,yaml,role=execute]
----
---
extends: ../config.yml

dependency:
    name: galaxy
    collections:
    - community.postgresql
----

. **Create `extensions/molecule/db_server/converge.yml`:**
   This playbook runs the `db_server` role.
[source,yaml,role=execute]
----
---
- name: Converge
    hosts: all
    tasks:
    - name: "Include the db_server role"
        ansible.builtin.include_role:
        name: "ansible_bootcamp.my_collection.db_server"
----

. **Create `extensions/molecule/db_server/verify.yml`:**
   This playbook functionally verifies the role's actions.
[source,yaml,role=execute]
----
---
- name: Verify
    hosts: all
    vars:
    db_name: "webapp_prod"
    db_user: "webapp_user"
    db_password: "SecurePassword123"
    tasks:
    - name: "FUNCTIONAL TEST: Connect as the new user and create a table"
        community.postgresql.postgresql_query:
        login_user: "{{ db_user }}"
        login_password: "{{ db_password }}"
        db: "{{ db_name }}"
        query: "CREATE TABLE IF NOT EXISTS molecule_verify (id INT);"

    - name: "FUNCTIONAL TEST: Write data to the new table"
        community.postgresql.postgresql_query:
        login_user: "{{ db_user }}"
        login_password: "{{ db_password }}"
        db: "{{ db_name }}"
        query: "INSERT INTO molecule_verify (id) VALUES (1);"

    - name: "FUNCTIONAL TEST: Read data back and verify the result"
        community.postgresql.postgresql_query:
        login_user: "{{ db_user }}"
        login_password: "{{ db_password }}"
        db: "{{ db_name }}"
        query: "SELECT COUNT(*) FROM molecule_verify;"
        register: query_result
        changed_when: false

    - name: "Assert that one record was found"
        ansible.builtin.assert:
        that:
            - query_result.query_result[0].count == 1
        fail_msg: "Verification failed! Expected to find 1 record but found {{ query_result.query_result[0].count }}."
        success_msg: "Verification successful! The DB user can connect, write, and read."
----
'''

== Step 4: Run the Full Test Suite!

From the root of your `ansible_bootcamp.my_collection` directory, execute the entire test suite using the `--all` flag.

[source,bash]
----
molecule test --all
----

Molecule will now execute the following sequence:
1.  **`default` scenario:** Runs the `create` action, starting the Docker container.
2.  **`db_server` scenario:** Runs `converge`, `idempotence`, and `verify` against the already-running container.
3.  **`default` scenario:** Runs the `destroy` action, cleaning up the Docker container.

This workflow perfectly matches the advanced pattern in the document and sets your students up for testing large, complex collections efficiently.
