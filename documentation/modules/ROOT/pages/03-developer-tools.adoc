= Lab: Automation Developer Experience

[abstract]
We will explore essential software development practices applied to automation development, including git workflows, secret scanning with pre-commit hooks, and comprehensive testing. This lab covers treating automation as code with proper linting, testing, and CI/CD practices, culminating in an overview of the Ansible Development Tools suite.

This lab walks through some of the basic software development pratices as they apply to automation development then ends with an overview of the Ansible Development Tools. All automation files should be treated as code. This means scanning for code syntax and quality, checking for secrets, and testing your code as much as possible before committing it. Once it is in git, consider it public and without effort will be there forever. 

== Git

While technically you can use something like a local directory for AAP, in general consider `git` a requirement. Furthermore, to properly scale automation across an enterprise, `git` _proficiency_ is required. 

NOTE: This lab covers the extreme basics of `git`. For many of you, this may be second nature so feel free to skip basic concepts you are already familiar with. This will not affect the lab later on. You will just miss some fun.

=== CLI Completion

While not required, sourcing these two files will greatly improve your CLI interactions. Note that this can also be added to the `devfile` or a local `.bashrc`

[source,bash,role=execute,subs="verbatim,attributes"]
----
source /usr/share/bash-completion/completions/git
source /usr/share/git-core/contrib/completion/git-prompt.sh
PS1='[\u \W$(__git_ps1 " (%s)")]\$ '
----

Notice your prompt will now display which branch you are in. Also, `git` sub commands now auto-complete with the TAB key. Feel free to customize this prompt as desired.

=== Set Global Settings

If you haven't done so already in this Ansible Workspace, set your global username and email:

[source,bash,role=execute,subs="verbatim,attributes"]
----
git config --global user.name "First Last"
git config --global user.email "email@example.com"
----

=== Branches

Branches should be used liberally. Test ideas and have no fear trashing a branch that didn't work. It's better to leave a branch is it is and start a new one based on your current working branch rather than testing a few things and reverting the commits or comment/uncomment things. Using the new `git` prompt outlined above should update when your branch changes as such:

[source,bash,subs="verbatim,attributes"]
----
[user devspaces-example (main)]$ git branch
* main

[user devspaces-example (main)]$ git checkout -b test
Switched to a new branch 'test'

[user devspaces-example (test)]$ git branch
  main
* test
----

=== Pull/Merge Requests

Pull/Merge requests are when you have work in a branch you want to merge into another branch. Typically this is a feature branch with your work that you want to merge into `main` but it could be any other branch target. PR/MRs are an essential way to review code and allow others to comment and provide feedback or changes. PR/MRs can also be used to kick off pipelines to run further commands on this branch of code.

=== Merge conflicts

When a change is detected on the same line and git is unable to automtically apply the changes, human intervention is needed.

=== Branch update strategies

When working in a branch, it is often necessary to ensure your branch has the latest commits that are in main. If it has been a while since you created or updated your branch, it could be several commits behind. 

_Merge_ will take two divergent branches and preserve their history, adding a commit to tie them together

_Rebase_ will rewind and play commits back in order resulting in a cleaner, more linear history, but can make merge conflicts more difficult to manage

=== Cleaning up git history

While you generally should not be editing git history, there are times where this is necessary. Perhaps commits were made with a default or incorrect `user.name` or `user.email` and needed to be corrected. Or perhaps secrets were leaked and though cleaned up in HEAD, they are still in git history. In these cases, it is possible to edit specific commits.

== Secrets Scanning 

It is absolutely vital that you never EVER commit any secrets to git. Even if you revert the commit or delete the file, it is still in history. Even if it is "just a lab server" or "only internal" a secret will trigger many security scans requiring additinal work to explain if it is valid and needs rotating or not. Just don't do it. This lab will walk through using a tool like `gitleaks` to help keep your secrets out of git.

First create a fake API-like key. The default regex and patterns will determine a UUID-like value to be similar to an API key:

[source,bash]
----
$ cd /projects/devspaces-example/
$ echo key=$(uuidgen) > secret
$ cat secret
key=3863b2c6-cc7b-4832-92b6-5b82d6b1a987
----

Pull the appropriate image first:

[source,bash]
----
$ podman pull docker.io/zricethezav/gitleaks:latest
Trying to pull docker.io/zricethezav/gitleaks:latest...
Getting image source signatures
Copying blob 91da3791a8e8 done   | 
Copying blob daed8b4062ea done   | 
Copying blob e590f02e913a done   | 
Copying blob 1747dece9491 done   | 
Copying config 49c41c2292 done   | 
Writing manifest to image destination
49c41c2292e05b683dd2dbbe7f7677ca397722f1f0364adf615a3a6913f71ade
----

Run `gitleaks` to scan the directory containing the generated fake secret:

[source,bash]
----
$ podman run -v /projects/devspaces-example/:/scan:Z zricethezav/gitleaks:latest dir -v /scan/

    ○
    │╲
    │ ○
    ○ ░
    ░    gitleaks

Finding:     key=3863b2c6-cc7b-4832-92b6-5b82d6b1a987
Secret:      3863b2c6-cc7b-4832-92b6-5b82d6b1a987
RuleID:      generic-api-key
Entropy:     3.583275
File:        /scan/secret
Line:        1
Fingerprint: /scan/secret:generic-api-key:1

1:43AM INF scanned ~15523 bytes (15.52 KB) in 10.9ms
1:43AM WRN leaks found: 1
----

The default rules should detect the UUID as an API key.

== Pre-Commit

Pre-commit is a tool that essentially hooks into `git` and runs additional tooling before the commit actualy writes to git history. This is a perfect way to automatically call things like `ansible-lint` and `gitleaks` before having to go back and squash or clean up git history.

Install pre-commit:

[source,bash,role=execute,subs="verbatim,attributes"]
----
$ pip install --user pre-commit
----

[source,bash]
----
Collecting pre-commit
  Downloading pre_commit-4.3.0-py2.py3-none-any.whl (220 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 221.0/221.0 kB 26.4 MB/s eta 0:00:00
Collecting cfgv>=2.0.0
  Downloading cfgv-3.4.0-py2.py3-none-any.whl (7.2 kB)
Collecting identify>=1.0.0
  Downloading identify-2.6.15-py2.py3-none-any.whl (99 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 99.2/99.2 kB 63.9 MB/s eta 0:00:00
Collecting nodeenv>=0.11.1
  Downloading nodeenv-1.9.1-py2.py3-none-any.whl (22 kB)
Requirement already satisfied: pyyaml>=5.1 in /usr/local/lib64/python3.11/site-packages (from pre-commit) (6.0.3)
Requirement already satisfied: virtualenv>=20.10.0 in /usr/local/lib/python3.11/site-packages (from pre-commit) (20.25.1)
Requirement already satisfied: distlib<1,>=0.3.7 in /usr/local/lib/python3.11/site-packages (from virtualenv>=20.10.0->pre-commit) (0.3.8)
Requirement already satisfied: filelock<4,>=3.12.2 in /usr/local/lib/python3.11/site-packages (from virtualenv>=20.10.0->pre-commit) (3.13.1)
Requirement already satisfied: platformdirs<5,>=3.9.1 in /usr/local/lib/python3.11/site-packages (from virtualenv>=20.10.0->pre-commit) (4.2.0)
Installing collected packages: nodeenv, identify, cfgv, pre-commit
  WARNING: The script nodeenv is installed in '/home/user/.local/bin' which is not on PATH.
  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
  WARNING: The script identify-cli is installed in '/home/user/.local/bin' which is not on PATH.
  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
  WARNING: The script pre-commit is installed in '/home/user/.local/bin' which is not on PATH.
  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
Successfully installed cfgv-3.4.0 identify-2.6.15 nodeenv-1.9.1 pre-commit-4.3.0
----

Notice the *WARNING:* this tells you the path the binary was installed to.

Add the following to `.pre-commit-config.yaml`:

[source,bash,role=execute,subs="verbatim,attributes"]
----
repos:
  - repo: https://github.com/gitleaks/gitleaks
    rev: v8.28.0
    hooks:
      - id: gitleaks
        name: gitleaks
        entry: podman run -v /projects/devspaces-example:/scan:Z zricethezav/gitleaks:latest dir -v /scan/
        language: system
        stages: [pre-commit]
----

Install the pre-commit hook:

[source,bash,role=execute,subs="verbatim,attributes"]
----
$ /home/user/.local/bin/pre-commit install

 pre-commit installed at .git/hooks/pre-commit
----

Attempt a `git commit` which should fail:

[source,bash]
----
$ git add secret
$ git commit

gitleaks.................................................................Failed
- hook id: gitleaks
- exit code: 1

○
    │╲
    │ ○
    ○ ░
    ░    gitleaks

Finding:     key=3863b2c6-cc7b-4832-92b6-5b82d6b1a987
Secret:      3863b2c6-cc7b-4832-92b6-5b82d6b1a987
RuleID:      generic-api-key
Entropy:     3.583275
File:        /gitleaks/secret
Line:        1
Fingerprint: /gitleaks/secret:generic-api-key:1

1:22AM INF scanned ~15523 bytes (15.52 KB) in 7.62ms
1:22AM WRN leaks found: 1

bash-5.1$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   secret

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .pre-commit-config.yaml

----

In this way a developer never needs to remember to run a tool before a commit, pre-commit will do it for you, keeping mistakes out of git history. For a more comprehensive pre-commit-config see https://github.com/redhat-cop/infra.aap_configuration/blob/devel/.pre-commit-config.yaml

== Ansible Development Tools (ADT)

In your terminal, view the installed Ansible Development Tools:

[source,bash]
----
$ adt --version
ansible-builder                          3.1.0
ansible-core                             2.19.3
ansible-creator                          25.9.0
ansible-dev-environment                  25.8.0
ansible-dev-tools                        25.8.3
ansible-lint                             25.9.2
ansible-navigator                        25.9.0
ansible-sign                             0.1.2
molecule                                 25.9.0
pytest-ansible                           25.8.0
tox-ansible                              25.8.0
----

More details available from: https://ansible.readthedocs.io/projects/dev-tools/

The curated list of tools installed as part of the Ansible automation developer tools package includes:

`ansible-builder`: a utility for building Ansible execution environments.

`ansible-core`: Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems.

`ansible-creator`: a utility for scaffolding Ansible projects and content with leading practices.

`ansible-lint`: a utility to identify and correct stylistic errors and anti-patterns in Ansible playbooks and roles.

`ansible-navigator`: a text-based user interface (TUI) for developing and troubleshooting Ansible content with execution environments.

`ansible-sign`: a utility for signing and verifying Ansible content.

`molecule`: Molecule aids in the development and testing of Ansible content: collections, playbooks and roles

`pytest-ansible`: a pytest testing framework extension that provides additional functionality for testing Ansible module and plugin Python code.

`tox-ansible`: an extension to the tox testing utility that provides additional functionality to check Ansible module and plugin Python code under different Python interpreters and Ansible core versions.

`ansible-dev-environment`: a utility for building and managing a virtual environment for Ansible content development.

=== VSCode Extension

All extensions should be loaded by now. If you are not familiar with the Ansible extension see https://ansible.readthedocs.io/projects/vscode-ansible/

. Open the Ansible extension on the left of the window
+
image::03-developer-tools/ansible-extension1.png[]
+
. For this lab we will not be using Lightspeed so feel free to close these panes
+
image::03-developer-tools/ansible-extension2.png[]

=== Creating a Playbook Project

Now that we have covered the basics of tools available as an automation developer, let's walk through bringing it all together.  While not a command-line tool, the VSCode extension ties together functionality of DevSpaces and Ansible Development Tools into the development Workspace you are currently using. This portion of the lab will walk through several aspects of automation development activities in this Workspace.

. Click on `Playbook project` and specify the following values:
+
image::03-developer-tools/ansible-creator1.png[]
+
.. Destination directory: `/projects/myproject`
.. Namespace: `mynamespace`
.. Collection: `mycollection`
. Click `Create`
+
image::03-developer-tools/ansible-creator2.png[]
+
. The logs will display in the box below that
. Click `Open Project` to open a new VSCode window with this new project
+
image::03-developer-tools/ansible-creator3.png[]
+
. Once the DevSpaces Workspace loads with the new folder structure, explore the directories and files created by `ansible-creator`, using industry standard good practices:
+
image::03-developer-tools/ansible-creator4.png[]
+
. The `inventory` directory contains a ready to use structure:
+
image::03-developer-tools/ansible-creator6.png[]
+
. The `collections` directory contains a simple role with a few tasks.
+
image::03-developer-tools/ansible-creator5.png[]

=== Running playbooks in VSCode

While you may be familar with `ansible-playbook` or even `ansible-navigator` on the CLI, VSCode provides a way to execute them via ClickOps if so desired.

==== Running playbooks via ansible-playbook in VSCode

. Right-click on the file at the base of the directory `site.yml` and choose `Run Ansible Playbook Via ...`
. Choose `Run playbook via  'ansible-playbook'`.
+
image::03-developer-tools/ansible-playbook1.png[]
+
. A terminal opens up with the results:
+
image::03-developer-tools/ansible-playbook2.png[]

==== Running playbooks via ansible-navigator in VSCode

. Right-click on the file at the base of the directory `site.yml` and choose `Run Ansible Playbook Via ...`
. Choose `Run playbook via  'ansible-navigator run'`.
+
image::03-developer-tools/ansible-navigator1.png[]
+
. This will open a terminal and run `ansible-navigator run site.yml --ee false`. When the run is finished you will see a `Complete` message in `ansible-navigator`:
+
image::03-developer-tools/ansible-navigator2.png[]
+
. Click inside the terminal and select one of the task output lines to get more information, e.g. `3`:
+
image::03-developer-tools/ansible-navigator3.png[]
+
. Once reviewed, hit `ESC` several times until you exit back to the terinal.
+
image::03-developer-tools/ansible-navigator4.png[]

==== Using ansible-lint in VSCode

The VSCode Ansible extension proactively runs `ansible-lint` on any playbook you are editing. Experiment with this tool to understand how the feature works.

. Add the following poorly written task to `site.yml`
+
[source,yaml,role=execute,subs="verbatim,attributes"]
----
  tasks:
    - debug:
        msg: "Hello"
----
+
. As soon as you finish editing, the autosave feature will kick in and run `ansible-lint`, notice the message and the bottom of the screen:
+
image::03-developer-tools/ansible-lint1.png[]
+
. The exention should have added red squiggly lines underneath `debug`, hover over it to see the violations:
+
image::03-developer-tools/ansible-lint2.png[]
+
. You can fix these manually, but why not let `ansible-lint` do that for you? Open the exension settings:
+
image::03-developer-tools/ansible-lint3.png[]
+
. Open `Settings` for the Ansible extension:
+
image::03-developer-tools/ansible-lint4.png[]
+
. Under the Ansible extension settings, click on the subsection `Validation` and enter `--fix` as an extra argument
+
image::03-developer-tools/ansible-lint5.png[]
+
. Close the settings page and save the file with either the main menu `File` -> `Save` or `CTRL/CMD + s`
. `ansible-lint --fix` will automatically correct errors
+
image::03-developer-tools/ansible-lint6.png[]
+
. Notice it did not fix every violation such as adding a `name:` key. Feel free to fix this manually. Not every rule is enforced automatically. See `man ansible-lint` for more info.

=== Creating a Collection project

You can close the previous project window and return to the original Workspace, or open the Ansible extension in this Workspace, it doesn't matter

. Click on the `Collection project` link.
. Enter the following details:
.. Namespace: `mynamespace`
.. Collection: `mycolleciton2`
.. Init path: this value should be autodetected for you as `/projects/myproject/.ansible/collections/ansible_collections`
. Click `Create`
. When complete, click `Open Collection`
+
image::03-developer-tools/ansible-creator7.png[]
+
. Explore the scafolded files to see their content
.. `.gitignore`: pre-loaded with settings to ignore files in our git repository and make our commits cleaner.
.. `test-requirements.txt`: Already includes the Ansible Python dependencies required for running our tests later.
.. `.github/workflows`: Sample workflow for your collection
.. `.pre-commit-config`: Includes many useful pre-commit tools
+
image::03-developer-tools/ansible-creator8.png[]
+
. Review the included sample role `run` and run it in your Workspace however you feel like using the tools learned in this lab.
+ 
image::03-developer-tools/ansible-creator9.png[]

== Conclusion

You have successfully learned essential software development practices applied to automation development:

. Git version control fundamentals including branching strategies and merge conflicts
. Secret scanning using gitleaks and pre-commit hooks for automated code quality checks
. Ansible Development Tools suite including ansible-lint, ansible-navigator, and VSCode extensions
. Creating and managing Ansible projects and collections through the VSCode interface

This foundation prepares you to develop automation content that follows industry best practices for code quality, security, and maintainability.

== Helpful Links

. https://github.com/gitleaks/gitleaks
. https://pre-commit.com
. https://github.com/redhat-cop/infra.aap_configuration/blob/devel/.pre-commit-config.yaml
. https://ansible.readthedocs.io/projects/dev-tools/
. https://ansible.readthedocs.io/projects/vscode-ansible/