= Lab: Managing Ansible Content with Private Automation Hub

[abstract]
We will create a custom Collection, publish it to a Private Automation Hub (PAH), build a custom Execution Environment (EE) from a Red Hat certified base image, and finally, run the automation from Ansible Automation Controller.

Content management is a critical component of enterprise automation. Instead of publishing and retrieving content directly from public sources, automation assets will be sourced from a local and trusted content source. This lab will guide you through the process of creating and publishing Ansible Content Collections to a Private Automation Hub, building custom Execution Environments, and integrating them with Ansible Automation Controller. 

== Learning Objectives

After completing this module, you will be able to:

* Understand the role and benefits of Private Automation Hub
* Create and publish custom Ansible Collections
* Build custom Execution Environments
* Integrate Collections with Automation Controller
* Manage content lifecycle in enterprise environments

== 1. Introduction: The Role of Private Automation Hub

A link:https://www.redhat.com/en/technologies/management/ansible/automation-hub[Private Automation Hub (PAH),window=_blank] acts as a central repository containing curated and trusted automation content. It allows you to manage, share, and control access to a curated set of Execution Environments and Ansible Content Collections.

=== 1.1: Importance of Private Automation Hub?

Private Automation Hub provides several key benefits for enterprise automation:

. Centralized Control: A single source of truth for all your certified automation content.
. Security & Trust: Ensures that teams are using approved and vetted collections and EEs.
. Dependency Management: Simplifies dependency resolution by providing a private, trusted source for collections.
. Scalability: Enables the distribution of automation content across large organizations.

== 2. Lab Setup: Configuring Your Environment

First, let's configure the steps that your Dev Spaces environment needs to communicate with your Private Automation Hub.

=== 2.1: Configure Ansible to Use PAH via Environment Variables

Instead of creating an _ansible.cfg_ configuration file with your secret token that is used to communicate with PAH, we will set environment variables. This is a more secure practice for local development as it prevents tokens from being accidentally committed to source control.

==== 2.1.1: Obtaining Your PAH API Token

Utilize the following steps to obtain your PAH API token:

. Launch the link:{aap_controller_web_url}[Private Automation Hub,window=_blank] web interface and login using the credentials from the xref:environment-details.adoc[Environment Details,window=_blank] page.
. From the navigation menu on the left, expand **Automation Content** and click on **API Token**.
+
image::04-managing-content-automation-hub/api-token-overview.png[API Token Overview]
+
. On the API Token page, click the **Generate token** button. Your API token will be displayed.
+
image::04-managing-content-automation-hub/api-token-generate.png[Generate an API Token]
+
. Click the Copy to clipboard icon to copy it.

image::04-managing-content-automation-hub/api-token-copy.png[Copy the API Token]

NOTE: Make sure to store the token securely, as it will not be displayed again.

==== Step 2.1.3: Set Environment Variables

In your Dev Spaces terminal, run the following commands. These variables will configure `ansible-galaxy` and `ansible-builder` to use your PAH instance to pull and push collections and execution environments.

First, set a new variable for your PAH API Token created previously

[source,bash,role=execute,subs="verbatim,attributes"]
----
export PAH_API_TOKEN='YOUR_API_TOKEN_HERE'
----

NOTE: Replace `YOUR_API_TOKEN_HERE` With the personal API token you just copied from PAH.

Next, set the environment variables for Ansible to communicate with PAH.

[source,bash,role=execute,subs="verbatim,attributes"]
----
# Set the list of servers Ansible should know about
export ANSIBLE_GALAXY_SERVER_LIST='published,certified,validated,community'

# Configure the 'published' repository
export ANSIBLE_GALAXY_SERVER_PUBLISHED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/published/'
export ANSIBLE_GALAXY_SERVER_PUBLISHED_TOKEN=$PAH_API_TOKEN

# Configure the 'certified' repository
export ANSIBLE_GALAXY_SERVER_CERTIFIED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/rh-certified/'
export ANSIBLE_GALAXY_SERVER_CERTIFIED_TOKEN=$PAH_API_TOKEN

# Configure the 'validated' repository
export ANSIBLE_GALAXY_SERVER_VALIDATED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/validated/'
export ANSIBLE_GALAXY_SERVER_VALIDATED_TOKEN=$PAH_API_TOKEN

# Configure the 'community' repository
export ANSIBLE_GALAXY_SERVER_COMMUNITY_URL='{aap_controller_web_url}/pulp_ansible/galaxy/community/'
export ANSIBLE_GALAXY_SERVER_COMMUNITY_TOKEN=$PAH_API_TOKEN
----

== 3. Creating and Publishing a Custom Collection

Now, let's use `ansible-creator`` to scaffold a new collection.

=== 3.1: Initialize the Collection with ansible-creator

[source,bash,role=execute,subs="verbatim,attributes"]
----
# Create a main project directory
mkdir my_pah_project
cd my_pah_project

# Initialize the collection structure using ansible-creator
ansible-creator init ansible_bootcamp.my_collection --init-path ./
----

=== 3.2: Publishing Collections

Publishing a Collection makes it available in PAH for use in Automation Controller and other tools. To publish a collection, a _namespace_ must exist in PAH for which the collection can be built and then published.

==== 3.2.1: Creating namespace for collection

Create a new _Namespace_ in PAH.

. Launch the link:{aap_controller_web_url}[Private Automation Hub,window=_blank] web interface and login using the credentials from the xref:environment-details.adoc[Environment Details,window=_blank] page.
. From the navigation menu on the left, expand **Automation Content** and click on **Namespaces**.
+
image::04-managing-content-automation-hub/navigate-namespaces.png[Namespaces navigation]
+
. Click on the **Create Namespace** button.
+
image::04-managing-content-automation-hub/namespaces-overview.png[Namespaces overview]
+
. Enter `ansible_bootcamp` for the name. The rest of the values can be left blank
. Click **Create Namespace** to create the namespace.

image::04-managing-content-automation-hub/create-namespace.png[Namespace creation form]

=== 3.3: Build and Publish the Collection

Now that a namespace exists, we can build and publish our collection to PAH.

[source,bash,role=execute,subs="verbatim,attributes"]
----
# Build your custom collection
ansible-galaxy collection build

# Publish the collection to PAH
ansible-galaxy collection publish -s {aap_controller_web_url}/api/galaxy/ ansible_bootcamp-my_collection-1.0.0.tar.gz --token $PAH_API_TOKEN
----

NOTE: You can safely ignore any warnings that may be emitted during the publishing process.

Once your collection has been published, it must be approved before it is available for use.

. Launch the link:{aap_controller_web_url}[Private Automation Hub,window=_blank] web interface and login using the credentials from the xref:environment-details.adoc[Environment Details,window=_blank] page.
. From the navigation menu on the left, expand **Automation Content** and click on **Collection Approvals**.
+
image::04-managing-content-automation-hub/collection-approvals-overview.png[Collection Approvals overview]
+
. The `ansible_bootcamp.my_collection` should be listed as pending approval. Click the **Thumbs Up** icon to approve and sign the collection.
+
image::04-managing-content-automation-hub/collections-approvals-pending.png[Approve the Collection]
+
. Select the _Yes, I confirm that I want to approve these 1 collections._ checkbox and click **Approve collections** button.
+
image::04-managing-content-automation-hub/collections-approvals-approve-collection.png[Pending Approval Collection]
+
. Navigate to the **Collections** page in PAH to verify that your collection is published and available.
+
image::04-managing-content-automation-hub/navigate-collections.png[Navigate to Collections]
+
. You should see your `ansible_bootcamp.my_collection` listed and available for use.

image::04-managing-content-automation-hub/pah-collections.png[PAH Collections]

== 4. Syncing a Base EE from the Red Hat Registry

Before building our own EE, we'll configure PAH to pull in a certified base image from Red Hat.

. In your Private Automation Hub UI, navigate to Execution Environments -> Remote Registries.
. Click Add remote registry and configure it for https://registry.redhat.io with your credentials.
. Once saved, edit the registry and add ansible-execution-env/ee-minimal-rhel9 to the include tags list.
. Save and Sync the registry.
. After the sync is complete, the ee-minimal-rhel9 image will be available in your Private Automation Hub.


== 5. Push Collection to Repository

After we've published our collection to Private Automation Hub, the next step is to save our work into your lab's Gitea instance.

=== 5.1 Create Gitea Repository

Create a new repository in your Gitea instance to hold the collection code using the following steps:

. Navigate to your link:{gitea_console_url}[Gitea instance] and click the **Sign In** button on the upper right hand corner
+ 
image::04-managing-content-automation-hub/gitea-homepage.png[Gitea Homepages]
+
. Enter the username and password using the credentials provided from the xref:environment-details.adoc[Environment Details,window=_blank] page and click the **Sign In** button
+ 
image::04-managing-content-automation-hub/gitea-login.png[Gitea Login Page]
+
. Once authenticated, in the top left of the web interface, click on the **+** symbol and select **New Repository**.
+
image::04-managing-content-automation-hub/gitea-navigate-new-repository.png[Navigate to new Gitea Repository]
+
. On the New Repository page, enter 'ansible_bootcamp_my_collection' in the Repository Name field.
+ 
image::04-managing-content-automation-hub/gitea-new-repository-name.png[Gitea New Repository]
+
. Leave everything else as default and click on the button at the bottom, **Create Repository**.

image::04-managing-content-automation-hub/gitea-create-repository.png[Gitea Create Repository]


==== 5.2 Append to the `.gitignore` file

Back in your Dev Spaces instance, update the `.gitignore` file within the `my_pah_project` directory containing the `my_collection` collection and append the following lines to exclude files that should not be committed to the repository.

[source,bash,role=execute,subs="verbatim,attributes",title=".gitignore"]
----
context/
.password
ansible.cfg
.vscode/
*.tar.gz
*.json

----

=== 5.3 Push collection to new repository

After an empty repository is created on your Gitea instance, the next step is to push the collection to the repository.

. Navigate to the link:{gitea_console_url}/{gitea_user}/ansible_bootcamp_my_collection[ansible_bootcamp_my_collection] repository.
. In the section _Clone this repository_, click the **Copy URL** icon on the far right to copy Gitea repository URL for the _HTTPS_ protocol option.

Now, from within the the terminal of your Dev Spaces instance, within the 'my_pah_project' directory, execute the following commands to initialize a new Git repository and push the content to the Gitea repository.

[source,bash,role=execute,subs="verbatim,attributes"]
----
git init
git checkout -b main
git add --all
git commit -m "Uploading collection on initial commit"
git remote add origin {gitea_console_url}/{gitea_user}/ansible_bootcamp_my_collection.git
git push -u origin main
----

Since the repository requires authentication, you will be prompted to enter your Gitea username and password at the top of the Dev Spaces window.

image::04-managing-content-automation-hub/devspaces-git-auth.png[Gitea Repository Containing Collection Content]

Once the credentials have been entered, the push operation will proceed in your terminal with a result similar to the following:

[source,bash,subs="verbatim,attributes"]
----
Enumerating objects: 83, done.
Counting objects: 100% (83/83), done.
Delta compression using up to 16 threads
Compressing objects: 100% (60/60), done.
Writing objects: 100% (83/83), 31.42 KiB | 3.14 MiB/s, done.
Total 83 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
remote: . Processing 1 references
remote: Processed 1 references in total
To {gitea_console_url}/{gitea_user}/ansible_bootcamp_my_collection.git
 * [new branch]      main -> main
branch 'main' set up to track 'origin/main'.
----

Refresh the `ansible_bootcamp_my_collection` page within the Gitea UI to confirm that the collection has been published successfully.

image::04-managing-content-automation-hub/gitea-repository.png[Dev Spaces Git Authentication]

The repository will be referenced later in the Ansible Bootcamp Lab: xref:06-ansible-cicd.adoc[Creating a CI/CD Pipeline]. 

== 6. Building a Custom Execution Environment

Now, we'll define and build an EE that uses our synced minimal image and our custom collection.

=== Step 6.1: Define the Execution Environment

Create a file named execution-environment.yml.

[source,yaml,title="execution-environment.yml",role=execute,subs="verbatim,attributes"]
----
---
version: 3

images:
  base_image:
    name: aap-aap.{openshift_cluster_ingress_domain}/ansible-automation-platform-25/ee-minimal-rhel9:latest

dependencies:
  ansible_core:
    package_pip: ansible-core==2.16.14
  galaxy:
    collections:
      - name: ansible_bootcamp.my_collection
        version: 1.0.0
options:
  package_manager_path: /usr/bin/microdnf

additional_build_steps:
  prepend_galaxy:
    - ARG TOKEN
    - ENV ANSIBLE_GALAXY_SERVER_LIST='published,certified,validated,community'
    - ENV ANSIBLE_GALAXY_SERVER_CERTIFIED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/rh-certified/'
    - ENV ANSIBLE_GALAXY_SERVER_CERTIFIED_TOKEN=$TOKEN
    - ENV ANSIBLE_GALAXY_SERVER_VALIDATED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/validated/'
    - ENV ANSIBLE_GALAXY_SERVER_VALIDATED_TOKEN=$TOKEN
    - ENV ANSIBLE_GALAXY_SERVER_COMMUNITY_URL='{aap_controller_web_url}/pulp_ansible/galaxy/community/'
    - ENV ANSIBLE_GALAXY_SERVER_COMMUNITY_TOKEN=$TOKEN
    - ENV ANSIBLE_GALAXY_SERVER_PUBLISHED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/published/'
    - ENV ANSIBLE_GALAXY_SERVER_PUBLISHED_TOKEN=$TOKEN
----

WARNING: Remove the https:// from the base_image name

=== Step 6.2: Build and Publish the Execution Environment

[source,bash,role=execute,subs="verbatim,attributes"]
----
# Log in to your PAH container registry
podman login {aap_controller_web_url}

# Build the EE. It will pull the base from PAH, then add our content.
ansible-builder build --tag my-pah-ee:1.0 --build-arg TOKEN=YOUR_API_TOKEN_HERE

# Tag and push the image to your PAH registry
podman tag localhost/my-pah-ee:1.0 {aap_controller_web_url}/my-pah-ee:1.0
podman push {aap_controller_web_url}/my-pah-ee:1.0
----

WARNING: Remove the https:// in these commands or it will error. Also update `YOUR_API_TOKEN_HERE` With the personal API token you just copied from PAH.

== 7. Adding a Custom Filter Plugin

Now that we have a working EE, let's iterate by adding a custom filter plugin to our collection.

=== Step 7.1: Create the Custom Filter Plugin

Create the file with the following content:

[source,python,title="plugins/filter/cowsay_filter.py",role=execute,subs="verbatim,attributes"]
----
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

DOCUMENTATION = '''
    name: cowsay
    short_description: A filter to wrap text in a cowsay bubble.
    description:
        - This filter takes a string and returns it formatted by the cowsay library.
    requirements:
      - The `cowsay` python library must be installed.
'''

try:
    import cowsay
except ImportError:
    cowsay = None

def cowsay_filter(text):
    if not cowsay:
        raise AnsibleFilterError("The 'cowsay' Python library is not installed. Cannot use filter.")
    return cowsay.cow(text)

class FilterModule(object):
    def filters(self):
        return {
            'cowsay': cowsay_filter
        }
----

=== Step 7.2: Update the EE Definition for the Plugin Dependency

Our new plugin requires the cowsay Python library, and we need to ensure our EE is pulling the new version of our collection. Modify execution-environment.yml to include both changes.

[source,yaml,title="execution-environment.yml",role=execute,subs="verbatim,attributes"]
----
---
version: 3

images:
  base_image:
    name: {aap_controller_web_url}/ansible-automation-platform-25/ee-minimal-rhel9:latest

dependencies:
  ansible_core:
    package_pip: ansible-core==2.16.14
  galaxy:
    collections:
      - name: ansible_bootcamp.my_collection
        version: 1.0.1
  python:
    - cowsay
options:
  package_manager_path: /usr/bin/microdnf

additional_build_steps:
  prepend_galaxy:
    - ARG TOKEN
    - ENV ANSIBLE_GALAXY_SERVER_LIST='published,certified,validated,community'
    - ENV ANSIBLE_GALAXY_SERVER_CERTIFIED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/rh-certified/'
    - ENV ANSIBLE_GALAXY_SERVER_CERTIFIED_TOKEN=$TOKEN
    - ENV ANSIBLE_GALAXY_SERVER_VALIDATED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/validated/'
    - ENV ANSIBLE_GALAXY_SERVER_VALIDATED_TOKEN=$TOKEN
    - ENV ANSIBLE_GALAXY_SERVER_COMMUNITY_URL='{aap_controller_web_url}/pulp_ansible/galaxy/community/'
    - ENV ANSIBLE_GALAXY_SERVER_COMMUNITY_TOKEN=$TOKEN
    - ENV ANSIBLE_GALAXY_SERVER_PUBLISHED_URL='{aap_controller_web_url}/pulp_ansible/galaxy/published/'
    - ENV ANSIBLE_GALAXY_SERVER_PUBLISHED_TOKEN=$TOKEN
----

WARNING: Remove the https:// from the base_image name

=== Step 7.3: Increment Version and Republish

Now, we publish a new version of the collection and a new version of the EE that includes the updated collection and dependency.

First, edit `galaxy.yml` and change the version from `1.0.0` to `1.0.1`.

Then, run the following commands:

[source,bash,role=execute,subs="verbatim,attributes"]
----
# Rebuild and republish the collection
ansible-galaxy collection build
ansible-galaxy collection publish -s {aap_controller_web_url}/api/galaxy/ ansible_bootcamp-my_collection-1.0.1.tar.gz --token YOUR_API_TOKEN_HERE
----

NOTE: Replace `YOUR_API_TOKEN_HERE` With the personal API token you just copied from PAH.

NOTE: Make sure to Approve collection in the hub UI

[source,bash,role=execute,subs="verbatim,attributes"]
----
# Rebuild and republish the EE with a new version tag
ansible-builder build --tag my-pah-ee:1.1 --build-arg TOKEN=YOUR_API_TOKEN_HERE
podman tag localhost/my-pah-ee:1.1 {aap_controller_web_url}/my-pah-ee:1.1
podman push {aap_controller_web_url}/my-pah-ee:1.1
----

WARNING: Remove the https:// in these commands or it will error.

== 8. Preparing the Project for Automation Controller

Now we'll update our playbook to use the new filter.

=== Step 8.1: Create a Playbook

Create a playbook named `playbooks/test_pah_ee.yml`. This playbook uses the debug module to print a message that has been formatted by our custom cowsay filter.

[source,yaml,title="playbooks/test_pah_ee.yml",role=execute,subs="verbatim,attributes"]
----
---
- name: Test custom filter from Private Automation Hub
  hosts: localhost
  connection: local
  gather_facts: false

  tasks:
    - name: Print a message using the cowsay filter
      ansible.builtin.debug:
        msg: "{{ 'Hello from my custom filter!' | ansible_bootcamp.my_collection.cowsay }}"
...
----

=== Step 8.2: Push Project Files to Git

Push all your new and updated files to your Git repository

== 9. Integrating with Automation Controller

Now, let's configure Controller to use our custom content.

=== Step 9.1: Create a Credential for Hub Container Registry
. Navigate to Automation Execution -> Infrastructure -> Credentials and click Add.
. Name it Hub, select the type Container Registry, and fill out your "Authentication URL": {aap_controller_web_url}, "username": {aap_controller_admin_user}, "password": {aap_controller_admin_password}.

=== Step 9.2: Add the Execution Environment to Controller
. Navigate to Automation Execution -> Infrastructure -> Execution Environments.
. Click Add, name it My Custom PAH EE, and use the image path `{aap_controller_web_url}/my-pah-ee:1.1`.
. Select your Hub credential as the registry credential and Save.

NOTE: Remove https://

=== Step 9.3: Create a Project
. Navigate to Automation Execution -> Projects and click Add.
. Name it Custom Content Test Project and point it to your Git repository URL.
. Under Ansible Galaxy Credentials, select the PAH Galaxy Credential you just created.
. Click Save and Sync the project.

=== Step 9.4: Create a Job Template
. Navigate to Automation Execution -> Templates and click Add -> Add job template.
. Name it Test Custom Cowsay Filter.
. Select an Inventory, the Custom Content Test Project, and the playbooks/test_pah_ee.yml playbook.
. For the Execution Environment, select My Custom PAH EE.
. Click Save.

=== Step 9.5: Launch the Job Template and Verify
. From the Job Templates view, click the rocket icon 🚀 to Launch your template.
. In the job output view, look for the output of the "Print a message" task. You should see your message printed inside a cowsay bubble within the JSON output of the debug task.

==== Step 9.6: Sync collections
. Log in to your Private Automation Hub web interface.
. From the navigation menu on the left, click on Remotes.
. Click on edit `community` copy and paste this in the requirements file section and click save.

[source,yaml,role=execute,subs="verbatim,attributes"]
----
collections:
  - name: containers.podman
  - name: community.postgresql
----

. Click on create remote and call it `validated` with url being `https://console.redhat.com/api/automation-hub/content/validated/` SSO url `https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token` and token.
. From the navigation menu on the left, click on Repositories.
. Edit validated and for the `Remote` field choose validated from the drop down and save.
. Click on the triple dots for `rh-certified`, `validated`, and `community` and select `Sync repository` and click sync on the popup.

NOTE: Syncing the certified collections will take some time, it is needed for another section so continue on and do not wait for it to finish.

== 10. Conclusion

Congratulations! You have successfully mastered the complete lifecycle of managing Ansible content in enterprise environments:

* **Environment Setup**: Configured your local environment to connect to a Private Automation Hub
* **Content Creation**: Built and published custom collections with advanced functionality (including filter plugins)
* **Environment Management**: Created custom Execution Environments with specific toolsets and dependencies
* **Hub Integration**: Configured Private Automation Hub for content distribution and management
* **Controller Integration**: Connected Automation Controller with custom content and environments
* **End-to-End Validation**: Verified the complete automation workflow from development to execution

This foundation enables you to create, manage, and distribute automation content at enterprise scale while maintaining security, compliance, and governance standards. The skills learned here are essential for managing automation in large organizations where content needs to be curated, controlled, and distributed efficiently.

== Helpful Links

For additional reference and deeper learning on managing Ansible content:

. https://docs.ansible.com/ansible/latest/galaxy/user_guide.html[Ansible Galaxy User Guide]
. https://docs.ansible.com/ansible/latest/collections_guide/index.html[Ansible Collections Guide]
. https://ansible.readthedocs.io/projects/builder/[Ansible Builder Documentation]
. https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.5/html/using_automation_hub/index[Private Automation Hub Documentation]
